diff --git a/lpac/driver/apdu/gbinder_hidl.c b/lpac/driver/apdu/gbinder_hidl.c
index 111cbb7..401a9f9 100644
--- a/lpac/driver/apdu/gbinder_hidl.c
+++ b/lpac/driver/apdu/gbinder_hidl.c
@@ -172,7 +172,7 @@ static int try_open_slot(int slotId, const uint8_t *aid, uint32_t aid_len)
     }
 
     // Now, try to open the AID
-    uint8_t aid_hex[255];
+    char aid_hex[255];
     euicc_hexutil_bin2hex(aid_hex, 255, aid, aid_len);
 
     req = gbinder_client_new_request(client);
@@ -214,9 +214,12 @@ static int apdu_interface_logic_channel_open(struct euicc_ctx *ctx, const uint8_
     // We only start to use gbinder connection here, because only now can we detect whether
     // a given slot is a valid eSIM slot. This way we can automatically fall back in the case
     // where a device has only one eSIM -- we don't want to force the user to choose in this case.
-    int res = try_open_slot(1, aid, aid_len);
-    if (res < 0)
-        res = try_open_slot(2, aid, aid_len);
+    int UIM_SLOT = 1;
+    if (getenv("UIM_SLOT"))
+        UIM_SLOT = atoi(getenv("UIM_SLOT"));
+    int res = try_open_slot(UIM_SLOT, aid, aid_len);
+    //if (res < 0)
+    //    res = try_open_slot(2, aid, aid_len);
     if (res >= 0)
         lastChannelId = res;
     return res;
@@ -241,7 +244,7 @@ static int apdu_interface_transmit(struct euicc_ctx *ctx, uint8_t **rx, uint32_t
     gbinder_local_request_init_writer(req, &writer);
     gbinder_writer_append_int32(&writer, 1000);
 
-    uint8_t tx_hex[4096] = {0};
+    char tx_hex[4096] = {0};
     euicc_hexutil_bin2hex(tx_hex, 4096, &tx[5], tx_len - 5);
 
     if (DEBUG)
diff --git a/lpac/src/main.c b/lpac/src/main.c
index 1131ec4..199ef47 100644
--- a/lpac/src/main.c
+++ b/lpac/src/main.c
@@ -167,7 +167,7 @@ int main(int argc, char **argv)
     apdu_driver = getenv(ENV_APDU_DRIVER);
     if (apdu_driver == NULL)
     {
-        apdu_driver = "pcsc";
+        apdu_driver = "gbinder_hidl";
     }
 
     http_driver = getenv(ENV_HTTP_DRIVER);
